## 1. 何为递归
```
递归在我们的生活中其实很常见。假设你去电影院看电影，黑漆漆一片，你不知道自己来到了第几排，于是你问前面的人他是第几排，知道了前面的人是第几排，加一也就是你所在的排数。但前面的人也不知道，于是他也继续向前问，直到第一排的人回答他在第一排，然后再依次往后传，最后你就知道了你现在位于第几排。
```

递归可以分为两个过程:
- 向前一直推进直到找到一个确定的解答为“递”，
- 倒推回来得到你想要的答案为“归”。

可以形象地概括为往前”递“，往后”归“。

## 2. 递归满足的条件

- 一个问题的解可以分解为几个子问题的解。开篇的例子中，‘”自己在第几排的问题“可以分解为“前面的人在第几排”的子问题。
- 问题和分解后的子问题，除了数据规模不一样，求解思路完全一样。
- 存在递归终止条件。不能无限制地“递”下去，第一排的人知道答案后就要“归”回来。

## 3. 实现递归的关键

- 基线条件(base case)，停止调用
- 递归条件(recursive case)， 自己调用自己

实现递归的关键就在于找到基线条件和递归条件。递归条件就是分解子问题的过程，基线条件就是找到递归终止的情况。
不要试图去弄清楚递归的详细过程，解决问题的时候要把重点放在，假设子问题已经得到解决的情况下，我们该如何求解。

## 4.递归策略
递归算法是把问题转化为规模缩小了的同类问题的子问题。然后递归调用函数（或过程）来表示问题的解。 
接下来，我们将通过同一个问题来分析两种策略。
### 4.1 减而治之（Decrease-and-conquer）
求解一个大规模的问题，可以将其划分为两个子问题，其一是**平凡问题**，另一个**规模**缩减。由子问题的解，得到原问题的解。
![](https://raw.githubusercontent.com/fray-hao/images/master/20190701165854.png)
![](https://raw.githubusercontent.com/fray-hao/images/master/20190701171249.png)

**典型应用**
1 折半查找
2 快速排序(每一次运行一次划分算法都只是排好了一个元素)
3 深度优先查找&广度优先查找
4 拓扑排序
5 插入排序
6 二叉查找树

### 4.2 分而治之（Divide-and-conquer）
为求解一个大规模的问题，可以将其划分为若干（通常两个）子问题，规模大体相当，分别求解子问题。由子问题解，得到原问题的解。
![](https://raw.githubusercontent.com/fray-hao/images/master/20190701171435.png)
![](https://raw.githubusercontent.com/fray-hao/images/master/20190701171513.png)

效果
分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象，而与原始问题相比，各个子问题的size变小了，这刚好符合递归的特性。因此，计算机算法中的分治策略往往与递归联系在一起。

典型应用
1 最大值最小值问题（引申：寻找第K小的元素）

2 整数乘法问题（二进制）

3 快速傅里叶变换*

4 几种基于分治的排序算法

    归并排序

    快速排序
   